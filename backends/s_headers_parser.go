package backends

import (
	"github.com/flashmob/go-guerrilla/mail"
	"github.com/flashmob/go-guerrilla/mail/mime"
)

// ----------------------------------------------------------------------------------
// Processor Name: HeadersParser
// ----------------------------------------------------------------------------------
// Description   : Populates the envelope.Header value
//-----------------------------------------------------------------------------------
// Requires      : "mimeanalyzer" stream processor to be enabled before it
// ----------------------------------------------------------------------------------
// Config Options: None
// --------------:-------------------------------------------------------------------
// Input         : e.Values["MimeParts"] generated by the mime processor
// ----------------------------------------------------------------------------------
// Output        : populates e.Header and e.Subject values of the envelope.
//               : Any encoded data in the subject is decoded to UTF-8
// ----------------------------------------------------------------------------------

func init() {
	Streamers["headersparser"] = func() *StreamDecorator {
		return StreamHeadersParser()
	}
}

const stateHeaderScanning = 0
const stateHeaderNotScanning = 1

func StreamHeadersParser() *StreamDecorator {

	sd := &StreamDecorator{}
	sd.Decorate =
		func(sp StreamProcessor, a ...interface{}) StreamProcessor {
			var (
				state    byte
				envelope *mail.Envelope
			)

			sd.Open = func(e *mail.Envelope) error {
				state = stateHeaderScanning
				envelope = e
				return nil
			}

			sd.Close = func() error {
				return nil
			}

			return StreamProcessWith(func(p []byte) (int, error) {
				switch state {
				case stateHeaderScanning:
					if mimeParts, ok := envelope.Values["MimeParts"].(*mime.Parts); ok {
						// copy the the headers of the first mime-part to envelope.Header
						// then call envelope.ParseHeaders()
						if len(*mimeParts) > 0 {
							headers := (*mimeParts)[0].Headers
							if headers != nil && len(headers) > 0 {
								state = stateHeaderNotScanning
								envelope.Header = headers
								_ = envelope.ParseHeaders()
							}
						}
					}
					return sp.Write(p)
				}
				// state is stateHeaderNotScanning
				// just forward everything to the underlying writer
				return sp.Write(p)

			})
		}

	return sd
}
